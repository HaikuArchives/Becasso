// © 2000-2001 Sum Software

#define BUILDING_ADDON
#include "BecassoAddOn.h"
#include "AddOnSupport.h"
#include <Button.h>
#include <CheckBox.h>
#include <Window.h>
#include <Application.h>
#include <Messenger.h>
#include <Screen.h>
#include <Beep.h>
#include <StringView.h>
#include <stdio.h>
#include <string.h>

// hey app set Active of Window X to true

class CaptureWindow : public BWindow {
  public:
	CaptureWindow(BRect rect)
		: BWindow(
			  rect, "WinGrab", B_TITLED_WINDOW,
			  B_NOT_RESIZABLE | B_NOT_ZOOMABLE | B_WILL_ACCEPT_FIRST_CLICK
		  ){};
	virtual ~CaptureWindow(){};

	virtual bool QuitRequested()
	{
		Hide();
		return false;
	};

	int fIndex;
	BCheckBox* fActivateCB;
	BCheckBox* fBorderCB;
};

CaptureWindow* window;
BMessenger theGrabbee;

status_t
window_for_messenger(BMessenger mgr, BMessenger* window, BLooper* us);
status_t
recurse_views(BMessenger view, BMessenger mgr, BMessenger* result);
const char*
nstr(char* d, const char* s, const int n);

class GrabView : public BView {
  public:
	GrabView(BRect rect, const char* name)
		: BView(rect, name, B_FOLLOW_LEFT | B_FOLLOW_TOP, B_WILL_DRAW)
	{
		fCamera = new BBitmap(BRect(0, 0, 31, 31), B_COLOR_8_BIT);
		uchar data[32 * 32] = {
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0x0f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0x0f, 0x06, 0x00, 0x06, 0x0f, 0x0f, 0x09, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0x0b, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x09, 0x00,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
			0x0f, 0x0f, 0x0f, 0x09, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0x00,
			0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x09, 0x00, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0x00, 0x0f, 0x0f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x09,
			0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0x2c, 0x0f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f,
			0x0f, 0x0f, 0x0f, 0x0f, 0x09, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0x2a, 0x2a, 0x0f,
			0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x09, 0x00, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
			0x0f, 0x09, 0x2c, 0x0f, 0x0f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
			0x09, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0f, 0x0f, 0x0f,
			0x0f, 0x0f, 0x0f, 0x05, 0x05, 0x09, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
			0x0f, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x05, 0x05, 0x05, 0x09, 0x00, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0x0f,
			0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0f, 0x0f, 0x0f, 0x08, 0x05, 0x05, 0x05,
			0x0f, 0x09, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0x00, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0f, 0x0f,
			0x0f, 0x08, 0x05, 0x05, 0x0f, 0x0f, 0x09, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0x07, 0x07, 0x07, 0x07, 0x00, 0x07, 0x0f,
			0x0f, 0x09, 0x00, 0x0f, 0x0f, 0x0f, 0x08, 0x07, 0x05, 0x0f, 0x0f, 0x09, 0x00, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x07, 0x07, 0x07, 0x0a,
			0x0a, 0x0c, 0x07, 0x07, 0x0f, 0x09, 0x09, 0x00, 0x0f, 0x0f, 0x0f, 0x08, 0x0f, 0x0f,
			0x0f, 0x0f, 0x00, 0x0b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
			0x00, 0x00, 0x07, 0x0c, 0x0f, 0x0f, 0x0f, 0x00, 0x0f, 0x09, 0x40, 0x09, 0x00, 0x0f,
			0x0f, 0x0f, 0x0c, 0x08, 0x07, 0x07, 0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0x00, 0x40, 0x40, 0x40, 0x40, 0x07, 0x0f, 0x0f, 0x0f, 0x07, 0x00, 0x09,
			0x40, 0x40, 0x09, 0x00, 0x0b, 0x00, 0x06, 0x09, 0x08, 0x08, 0x05, 0x00, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0xff, 0x3f, 0x3f, 0x40, 0x40, 0x40, 0x0f, 0x0f,
			0x0f, 0x0f, 0x00, 0x09, 0x3f, 0x40, 0x40, 0x0f, 0x00, 0x0b, 0x09, 0x09, 0x08, 0x08,
			0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x40, 0x3f, 0x40, 0x40,
			0x40, 0x40, 0x06, 0x0f, 0x0f, 0x0f, 0x00, 0x0f, 0x09, 0x3f, 0x40, 0x0f, 0x00, 0x0b,
			0x09, 0x09, 0x08, 0x08, 0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
			0x40, 0x3f, 0x40, 0x40, 0x40, 0x40, 0x00, 0x0f, 0x0b, 0x07, 0x00, 0x0f, 0x0f, 0x09,
			0x3f, 0x0f, 0x00, 0x0b, 0x09, 0x09, 0x08, 0x08, 0x05, 0x00, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0x06, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x0b, 0x07, 0x07,
			0x00, 0x0f, 0x0f, 0x0f, 0x09, 0x0f, 0x00, 0x0b, 0x09, 0x09, 0x08, 0x08, 0x05, 0x00,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
			0x00, 0x07, 0x07, 0x00, 0x09, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0b, 0x09, 0x09,
			0x08, 0x08, 0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x40,
			0x40, 0x40, 0x40, 0x40, 0x0f, 0x00, 0x00, 0x09, 0x09, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
			0x00, 0x0b, 0x09, 0x09, 0x08, 0x08, 0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0x09, 0x09, 0x40, 0x40, 0x40, 0x00, 0xff, 0xff, 0xff, 0x00, 0x09, 0x09,
			0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0b, 0x09, 0x09, 0x08, 0x08, 0x05, 0x00, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x09, 0xff, 0xff, 0xff,
			0xff, 0xff, 0x00, 0x09, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0b, 0x09, 0x09, 0x08, 0x08,
			0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x09, 0x0f, 0x0f, 0x0f, 0x00, 0x0b,
			0x09, 0x09, 0x08, 0x08, 0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x09,
			0x0f, 0x0f, 0x00, 0x0b, 0x09, 0x09, 0x08, 0x08, 0x05, 0x00, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0x00, 0x09, 0x0f, 0x00, 0x0b, 0x09, 0x09, 0x08, 0x08, 0x05, 0x00,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x09, 0x00, 0x0b, 0x09, 0x09,
			0x08, 0x08, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
			0x00, 0x09, 0x07, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff
		};
		uint8* dp = (uint8*)fCamera->Bits();
		for (int32 i = 0; i < 32 * 32; i++) {
			*dp++ = data[i];
		}
	}

	~GrabView() {}

	virtual void Draw(BRect update);
	virtual void MouseDown(BPoint point);
	virtual void MessageReceived(BMessage* msg);

  private:
	typedef BView inherited;
	BBitmap* fCamera;
};

void
GrabView::MouseDown(BPoint /*point*/)
{
	BBitmap* dragmap = new BBitmap(fCamera);
	BMessage* dragmsg = new BMessage(B_GET_PROPERTY);
	dragmsg->AddSpecifier("Window");
	DragMessage(dragmsg, dragmap, B_OP_OVER, BPoint(15, 15));
	delete dragmsg;
}

const char*
nstr(char* d, const char* s, const int n)
{
	d[0] = 0;
	for (int i = 0; i < n; i++)
		strcat(d, s);
	return d;
}

#define MAX_DEPTH 64

status_t
recurse_views(BMessenger view, BMessenger mgr, BMessenger* result)
{
	static int depth = 0;
	static bool found = false;
	static int viewnumber[MAX_DEPTH];

	// printf ("Entering depth %d\n", depth);

	depth++;

	BMessage reply;
	BMessage* msg = NULL;

	msg = new BMessage(B_GET_PROPERTY);
	msg->AddSpecifier("InternalName");
	for (int i = depth - 2; i >= 0; i--)
		msg->AddSpecifier("View", viewnumber[i]);

	view.SendMessage(msg, &reply);
	delete msg;

	//	char indent[80];
	//	printf ("%sInternal Name: %s ", nstr (indent, "   ", depth), reply.FindString ("result"));
	//	fflush (stdout);

	if (view == mgr) {
		*result = view;
		//		printf ("Found!\n");
		found = true;
		depth--;
		return B_OK; // Found it
	}

	// Check the children of the view
	int num_views;
	msg = new BMessage(B_COUNT_PROPERTIES);
	msg->AddSpecifier("View");
	for (int i = depth - 2; i >= 0; i--) {
		msg->AddSpecifier("View", viewnumber[i]);
	}
	view.SendMessage(msg, &reply);
	delete msg;
	num_views = reply.FindInt32("result");
	//	printf ("(%i Children)\n", num_views);

	for (int j = 0; j < num_views; j++) {
		//		printf ("[%i]", j); fflush (stdout);
		BMessenger theview;
		msg = new BMessage(B_GET_PROPERTY);
		viewnumber[depth - 1] = j;

		for (int i = depth - 1; i >= 0; i--) {
			msg->AddSpecifier("View", viewnumber[i]);
		}
		view.SendMessage(msg, &reply);
		delete msg;
		reply.FindMessenger("result", &theview);

		if (mgr == theview) {
			*result = theview;
			//			printf ("It's a kid...\n");
			found = true;
			depth--;
			return B_OK;
		}
		else {
			if (recurse_views(view, mgr, result) == B_OK) {
				//				printf ("Found in a kid\n");
				depth--;
				return B_OK;
			}
		}
		// Nope, not a child of this one.  Try the next...
	}
	depth--;
	return B_ERROR;
}

status_t
window_for_messenger(BMessenger mgr, BMessenger* window, BLooper* us)
{
	BMessage* msg = new BMessage(B_GET_SUPPORTED_SUITES);
	BMessage reply;

	// Check to see if it ain't us ourselves..!
	BLooper* looper;
	mgr.Target(&looper);
	if (looper == us)
		return B_ERROR;

	mgr.SendMessage(msg, &reply);
	delete msg;
	int i = 0;
	const char* suite;
	bool supported = false;
	while (reply.FindString("suites", i++, &suite) == B_OK) {
		if (!strcmp(suite, "suite/vnd.Be-window"))
			supported = true;
	}

	if (supported) // The thing _is_ a window!
	{
		*window = mgr;
		return B_OK;
	}

	msg = new BMessage(B_GET_PROPERTY);
	msg->AddSpecifier("InternalName");
	mgr.SendMessage(msg, &reply);
	delete msg;
	//	printf ("Internal name: %s\n", reply.FindString ("result"));

	// Alas.  Walk along all the windows of the app, and compare BMessengers of
	// all the views within those.  It sucks, but such is life.
	team_id team = mgr.Team();

	BMessenger app(NULL, team);
	msg = new BMessage(B_COUNT_PROPERTIES);
	msg->AddSpecifier("Window");
	app.SendMessage(msg, &reply);
	delete msg;

	int num_windows = reply.FindInt32("result");

	//	printf ("This app has %i windows\n", num_windows);
	for (int i = 0; i < num_windows; i++) {
		if (looper // The camera was dropped on one of our own windows, so tread with caution...
			&& be_app->WindowAt(i)->Looper() == us) {
			// skip this one
		}
		else {
			BMessenger thewin;
			msg = new BMessage(B_GET_PROPERTY);
			msg->AddSpecifier("Window", i);
			app.SendMessage(msg, &reply);
			delete msg;
			reply.FindMessenger("result", &thewin);

			int num_views;
			msg = new BMessage(B_COUNT_PROPERTIES);
			msg->AddSpecifier("View");
			thewin.SendMessage(msg, &reply);
			delete msg;
			num_views = reply.FindInt32("result");

			msg = new BMessage(B_GET_PROPERTY);
			msg->AddSpecifier("Title");
			thewin.SendMessage(msg, &reply);
			delete msg;

			//			printf ("Window %i (%s) has %i view(s)\n", i, reply.FindString ("result"),
			//num_views);
			for (int j = 0; j < num_views; j++) {
				BMessenger theview;
				msg = new BMessage(B_GET_PROPERTY);
				msg->AddSpecifier("View", j);
				thewin.SendMessage(msg, &reply);
				delete msg;
				reply.FindMessenger("result", &theview);

				BMessenger result;
				if (recurse_views(theview, mgr, &result) == B_OK) {
					*window = thewin;
					return B_OK;
				}
			}
		}
	}

	//	printf ("Not found!\n");
	beep();
	return B_ERROR;
}

void
GrabView::MessageReceived(BMessage* msg)
{
	switch (msg->what) {
		//	case 'Bdrg':
		//		break;
	case B_MESSAGE_NOT_UNDERSTOOD: {
		//		printf ("Message not understood by target...\n");
		BMessenger grabtarget = msg->ReturnAddress();
		if (grabtarget.IsValid()) {
			BMessage reply;
			BMessage* msg = new BMessage(B_GET_PROPERTY);
			msg->AddSpecifier("Title");
			grabtarget.SendMessage(msg, &reply);
			reply.PrintToStream();
			delete msg;
		}
		break;
	}
	case B_REPLY: {
		BMessenger AppWindow;
		if (msg->FindMessenger("result", &AppWindow) == B_OK) {
			if (window_for_messenger(AppWindow, &theGrabbee, Window()) == B_OK) {
				BMessage* msg = new BMessage(CAPTURE_READY);
				msg->AddInt32("index", window->fIndex);
				be_app->PostMessage(msg);
				delete msg;
			}
			else
				printf("Couldn't find the window.\n");
		}
		break;
	}
	case 'actv':
		//		printf ("Activate\n");
		break;
	case 'brdr':
		//		printf ("Border\n");
		break;
	default:
		msg->PrintToStream();
		inherited::MessageReceived(msg);
	}
}

void
GrabView::Draw(BRect update)
{
	SetLowColor(218, 218, 218);
	FillRect(update, B_SOLID_LOW);
	SetDrawingMode(B_OP_OVER);
	DrawBitmap(fCamera);
}

status_t
addon_init(uint32 index, becasso_addon_info* info)
{
	strcpy(info->name, "WinGrab");
	strcpy(info->author, "Sander Stoks");
	strcpy(info->copyright, "© 2000-2001 ∑ Sum Software");
	strcpy(info->description, "Grab a screen shot of a window");
	info->type = BECASSO_CAPTURE;
	info->index = index;
	info->version = 0;
	info->release = 2;
	info->becasso_version = 2;
	info->becasso_release = 0;
	info->does_preview = true;
	BRect rect(100, 180, 100 + 188, 180 + 72);
	window = new CaptureWindow(rect);
	rect.OffsetTo(B_ORIGIN);
	BView* bg = new BView(rect, "bg", B_FOLLOW_ALL_SIDES, B_WILL_DRAW);
	bg->SetViewColor(LightGrey);
	window->AddChild(bg);
	//	BMessage *msg = new BMessage (CAPTURE_READY);
	//	msg->AddInt32 ("index", index);
	//	BButton *grab = new BButton (BRect (128, 40, 180, 64), "grab", "Grab", msg);
	//	grab->SetTarget (be_app);
	//	bg->AddChild (grab);
	GrabView* gv = new GrabView(BRect(8, 8, 8 + 32, 8 + 32), "GrabView");
	bg->AddChild(gv);
	window->fActivateCB = new BCheckBox(
		BRect(48, rect.top + 2, rect.right - 4, rect.top + 18), "activate", "Activate",
		new BMessage('actv')
	);
	window->fBorderCB = new BCheckBox(
		BRect(48, rect.top + 20, rect.right - 4, rect.top + 36), "border", "Include Frame",
		new BMessage('brdr')
	);
	bg->AddChild(window->fActivateCB);
	bg->AddChild(window->fBorderCB);
	window->fActivateCB->SetValue(false);
	window->fBorderCB->SetValue(true);
	bg->AddChild(new BStringView(
		BRect(rect.left + 4, rect.bottom - 20, rect.right - 4, rect.bottom - 4), "dragtext",
		"Drag Camera onto a Window"
	));
	window->fIndex = index;
	window->Run();
	return B_OK;
}

status_t
addon_exit(void)
{
	return B_OK;
}

status_t
addon_open(void)
{
	window->Lock();
	if (window->IsHidden())
		window->Show();
	else
		window->Activate();
	window->Unlock();
	return B_OK;
}

BBitmap*
bitmap(char* title)
{
	if (theGrabbee.IsValid()) {
		BMessage reply;
		BMessage* msg = new BMessage(B_GET_PROPERTY);
		msg->AddSpecifier("Title");
		theGrabbee.SendMessage(msg, &reply);
		const char* result = reply.FindString("result");
		if (result)
			strcpy(title, result);
		else
			strcpy(title, "Grabbed Window");
		delete msg;

		if (window->fActivateCB->Value()) {
			msg = new BMessage(B_SET_PROPERTY);
			msg->AddSpecifier("Active");
			msg->AddBool("data", true);
			theGrabbee.SendMessage(msg, &reply);
			snooze(500000); // give the window time to paint
			delete msg;
		}

		msg = new BMessage(B_GET_PROPERTY);
		msg->AddSpecifier("Frame");
		theGrabbee.SendMessage(msg, &reply);
		delete msg;

		BRect frame;
		if (reply.FindRect("result", &frame) != B_OK) {
			beep();
			return 0;
		}

		int tab = 0;
		if (window->fBorderCB->Value()) {
			msg = new BMessage(B_GET_PROPERTY);
			msg->AddSpecifier("Look");
			theGrabbee.SendMessage(msg, &reply);

			window_look look = (window_look)reply.FindInt32("result");
			switch (look) {
			case B_BORDERED_WINDOW_LOOK:
				frame.InsetBy(-1, -1);
				break;
			case B_TITLED_WINDOW_LOOK:
			case B_DOCUMENT_WINDOW_LOOK:
				frame.InsetBy(-5, -5);
				frame.top -= 19;
				tab = 19;
				break;
			case B_MODAL_WINDOW_LOOK:
				frame.InsetBy(-5, -5);
				frame.PrintToStream();
				break;
			case B_FLOATING_WINDOW_LOOK:
				frame.InsetBy(-3, -3);
				frame.top -= 15;
				tab = 15;
				break;
			default:
				break;
			}
		}

		BScreen screen;
		BBitmap* bs = NULL;
		if (frame.left < 0)
			frame.left = 0;
		if (frame.top < 0)
			frame.top = 0;
		if (frame.right > screen.Frame().right)
			frame.right = screen.Frame().right;
		if (frame.bottom > screen.Frame().bottom)
			frame.bottom = screen.Frame().bottom;
		screen.GetBitmap(&bs, false, &frame);

		// This exercise is necessary because the grabbed image has
		// all kinds of weird stuff in its alpha channel.

		frame.OffsetTo(B_ORIGIN);
		BBitmap* b = new BBitmap(frame, B_RGB_32_BIT, true);
		BView* v = new BView(frame, "tmp view", 0, 0);
		b->Lock();
		b->AddChild(v);
		v->DrawBitmap(bs, B_ORIGIN);
		b->RemoveChild(v);
		b->Unlock();
		delete v;
		delete bs;

		bgra_pixel* s = (bgra_pixel*)b->Bits() - 1;
		for (int32 i = (frame.IntegerWidth() + 1) * (frame.IntegerHeight() + 1); i > 0; i--) {
			*s = *(++s) | ALPHA_MASK;
		}

		// correct for the tab
		if (tab) {
			s = (bgra_pixel*)b->Bits() + b->BytesPerRow() / 4 + 1;
			bgra_pixel tc = *s;
			int32 tw = 2;
			while (*(s++) == tc)
				tw++;
			for (int32 h = 0; h < tab; h++) {
				s = (bgra_pixel*)b->Bits() + h * b->BytesPerRow() / 4 + tw - 1;
				for (int32 w = tw; w <= b->Bounds().IntegerWidth(); w++)
					*s = *(++s) & COLOR_MASK;
			}
		}

		return (b);
	}
	else
		return (NULL);
}
